%MYNEURALNETWORKFUNCTION neural network simulation function.
%
% Auto-generated by MATLAB, 01-May-2019 15:50:49.
%
% [y1,xf1] = myNeuralNetworkFunction(x1,xi1) takes these arguments:
%   x1 = 2xTS matrix, input #1
%   xi1 = 2x10 matrix, initial 10 delay states for input #1.
% and returns:
%   y1 = 1xTS matrix, output #1
%   xf1 = 2x10 matrix, final 10 delay states for input #1.
% where TS is the number of timesteps.

% ===== NEURAL NETWORK CONSTANTS =====
clear all
clc

x1 = [2339; 76];
xi1 = [2305        2316        2315        2308        2280        2326        2341        2357        2351        2341;
      77          77          74          76          77          76          77          81          80          78];

% Input 1
x1_step1.xoffset = [588;52];
x1_step1.gain = [0.000550206327372765;0.0045662100456621];
x1_step1.ymin = -1;

% Layer 1
b1 = [-4.8103382239472978199;6.4804560577834831037];

IW1_1 = [9.658126969864468947 5.7803138312073132354 8.6163694803768269281 -7.7437324618457283876 0.63693086216754069007 -1.1985263984659919601 1.7785112048310540711 -4.4016892103714821971; 2.6799973798106964118 11.145532382973078356 4.1091271677359548775 -4.3552098095804483435 -3.236936550927393963  -0.65041196947934065697 1.6218775396418851908 -4.0375731021670482335];

% Layer 2
b2 = -2.2920076624970211476;
LW2_1 = [20.902116062013480047 13.339710972299895886];

% Output 1
y1_step1.ymin = -1;
y1_step1.gain = 2;
y1_step1.xoffset = 0;

% ===== SIMULATION ========

% Dimensions
ts = size(x1,2); % timesteps

% Input 1 Delay States
xd1 = mapminmax_apply(xi1,x1_step1);
xd1 = [xd1 zeros(2,1)];

% Allocate Outputs
y1 = zeros(1,ts);

% Rotating delay state position
xdts = mod(ts+3,5)+1;
    
% Input 1
xd1(:,xdts) = mapminmax_apply(x1(:,ts),x1_step1);
% Layer 1
tapdelay1 = reshape(xd1(:,mod(xdts-[1 2 3 4]-1,5)+1),8,1);

%ax = IW1_1 * ones(20,1);
axx = IW1_1 * tapdelay1;
axxx = b1 + IW1_1*tapdelay1;
a1 = tansig_apply(b1 + IW1_1*tapdelay1);

% Layer 2
a2 = b2 + LW2_1*a1;
y1(:,ts) = mapminmax_reverse(a2,y1_step1)

% % Time loop
%     

%     

%     

%     
%     % Output 1
%     y1(:,ts) = mapminmax_reverse(a2,y1_step1);

% 
% % Final delay states
% finalxts = TS+(1: 10);
% xits = finalxts(finalxts<=10);
% xts = finalxts(finalxts>10)-10;
% xf1 = [xi1(:,xits) x1(:,xts)];
% end

% ===== MODULE FUNCTIONS ========

% Map Minimum and Maximum Input Processing Function
function y = mapminmax_apply(x,settings)
y = bsxfun(@minus,x,settings.xoffset);
y = bsxfun(@times,y,settings.gain);
y = bsxfun(@plus,y,settings.ymin);
end

% Sigmoid Symmetric Transfer Function
function a = tansig_apply(n,~)
a = 2 ./ (1 + exp(-2*n)) - 1;
end

% Map Minimum and Maximum Output Reverse-Processing Function
function x = mapminmax_reverse(y,settings)
x = bsxfun(@minus,y,settings.ymin);
x = bsxfun(@rdivide,x,settings.gain);
x = bsxfun(@plus,x,settings.xoffset);
end
